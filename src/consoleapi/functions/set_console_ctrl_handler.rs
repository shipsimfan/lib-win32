use crate::{BOOL, PHANDLER_ROUTINE};

// rustdoc imports
#[allow(unused_imports)]
use crate::{
    CreateWindowEx, ENABLE_PROCESSED_INPUT, FALSE, GetLastError, SetConsoleMode, TRUE,
    WM_ENDSESSION, WM_QUERYENDSESSION,
};
#[allow(unused_imports)]
use std::ptr::null_mut;

#[link(name = "Kernel32")]
unsafe extern "system" {
    /// Adds or removes an application-defined handler routine function from the list of handler
    /// functions for the calling process.
    ///
    /// If no handler function is specified, the function sets an inheritable attribute that
    /// determines whether the calling process ignores `CTRL+C` signals.
    ///
    /// # Parameters
    ///  * `handler_routine` - A pointer to the application-defined handler routine function to be
    ///                        added or removed. This parameter can be [`null_mut`].
    ///  * `add` - If this parameter is [`TRUE`], the handler is added; if it is [`FALSE`], the
    ///            handler is removed. If the `handler_routine` parameter is [`null_mut`], a
    ///            [`TRUE`] value causes the calling process to ignore `CTRL+C` input, and a
    ///            [`FALSE`] value restores normal processing of `CTRL+C` input. This attribute of
    ///            ignoring or processing `CTRL+C` is inherited by child processes.
    ///
    /// # Return Value
    /// If the function succeeds, the return value is nonzero.
    ///
    /// If the function fails, the return value is zero. To get extended error information, call
    /// [`GetLastError`].
    ///
    /// # Remarks
    /// This function provides a similar notification for console application and services that
    /// [`WM_QUERYENDSESSION`] provides for graphical applications with a message pump. You could
    /// also use this function from a graphical application, but there is no guarantee it would
    /// arrive before the notification from [`WM_QUERYENDSESSION`].
    ///
    /// Each console process has its own list of application-defined handler routine functions that
    /// handle `CTRL+C` and `CTRL+BREAK` signals. The handler functions also handle signals
    /// generated by the system when the user closes the console, logs off, or shuts down the
    /// system. Initially, the handler list for each process contains only a default handler
    /// function that calls the [`ExitProcess`] function. A console process adds or removes
    /// additional handler functions by calling the [`SetConsoleCtrlHandler`] function, which does
    /// not affect the list of handler functions for other processes. When a console process
    /// receives any of the control signals, its handler functions are called on a last-registered,
    /// first-called basis until one of the handlers returns [`TRUE`]. If none of the handlers
    /// returns [`TRUE`], the default handler is called.
    ///
    /// Calling [`AttachConsole`], [`AllocConsole`], or [`FreeConsole`] will reset the table of
    /// control handlers in the client process to its initial state. Handlers must be registered
    /// again when the attached console session changes.
    ///
    /// For console processes, the `CTRL+C` and `CTRL+BREAK` key combinations are typically treated
    /// as signals ([`CTRL_C_EVENT`] and [`CTRL_BREAK_EVENT`]). When a console window with the
    /// keyboard focus receives `CTRL+C` or `CTRL+BREAK`, the signal is typically passed to all
    /// processes sharing that console.
    ///
    /// `CTRL+BREAK` is always treated as a signal, but typical `CTRL+C` behavior can be changed in
    /// three ways that prevent the handler functions from being called:
    ///  - The [`SetConsoleMode`] function can disable the [`ENABLE_PROCESSED_INPUT`] mode for a
    ///    console's input buffer, so `CTRL+C` is reported as keyboard input rather than as a
    ///    signal.
    ///  - Calling [`SetConsoleCtrlHandler`] with the [`null_mut`] and [`TRUE`] arguments causes
    ///    the calling process to ignore `CTRL+C` signals. This attribute is inherited by child
    ///    processes, but it can be enabled or disabled by any process without affecting existing
    ///    processes.
    ///  - If a console process is being debugged and `CTRL+C` signals have not been disabled, the
    ///    system generates a [`DBG_CONTROL_C`] exception. This exception is raised only for the
    ///    benefit of the debugger, and an application should never use an exception handler to
    ///    deal with it. If the debugger handles the exception, an application will not notice the
    ///    `CTRL+C`, with one exception: alertable waits will terminate. If the debugger passes the
    ///    exception on unhandled, `CTRL+C` is passed to the console process and treated as a
    ///    signal, as previously discussed.
    ///
    /// A console process can use the [`GenerateConsoleCtrlEvent`] function to send a `CTRL+C` or
    /// `CTRL+BREAK` signal to a console process group.
    ///
    /// The system generates [`CTRL_CLOSE_EVENT`], [`CTRL_LOGOFF_EVENT`], and
    /// [`CTRL_SHUTDOWN_EVENT`] signals when the user closes the console, logs off, or shuts down
    /// the system so that the process has an opportunity to clean up before termination. Console
    /// functions, or any C run-time functions that call console functions, may not work reliably
    /// during processing of any of the three signals mentioned previously. The reason is that some
    /// or all of the internal console cleanup routines may have been called before executing the
    /// process signal handler.
    ///
    /// *Windows 7, Windows 8, Windows 8.1 and Windows 10:*
    ///
    /// If a console application loads the gdi32.dll or user32.dll library, the handler routine
    /// function that you specify when you call [`SetConsoleCtrlHandler`] does not get called for
    /// the [`CTRL_LOGOFF_EVENT`] and [`CTRL_SHUTDOWN_EVENT`] events. The operating system
    /// recognizes processes that load gdi32.dll or user32.dll as Windows applications rather than
    /// console applications. This behavior also occurs for console applications that do not call
    /// functions in gdi32.dll or user32.dll directly, but do call functions such as Shell
    /// functions that do in turn call functions in gdi32.dll or user32.dll.
    ///
    /// To receive events when a user signs out or the device shuts down in these circumstances,
    /// create a hidden window in your console application, and then handle the
    /// [`WM_QUERYENDSESSION`] and [`WM_ENDSESSION`] window messages that the hidden window
    /// receives. You can create a hidden window by calling the [`CreateWindowEx`] method with the
    /// `ex_style` parameter set to 0.
    pub fn SetConsoleCtrlHandler(handler_routine: PHANDLER_ROUTINE, add: BOOL) -> BOOL;
}
